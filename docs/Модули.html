<!DOCTYPE html>
<html lang = "ru">
    <head>
        <meta charset = "utf-8">
        <title>Модули</title>
    </head>
    <body>
        <p>Модули</p>

        <h1>Модули</h1>

        <hr />
        <h2>DNS.py</h2>

        <p>Сий чудо-модуль содержит авторскую реализацию типа данных СНМ (Система Непересекающихся множеств), простую, как угол дома, и надёжную, как кувалда. С ней можно вытворять следующие вещи:</p>

        <h4><strong>Создание:</strong></h4>

        <p><strong>dns&nbsp;= DNS(n : int)</strong>, где:</p>

        <ul>
            <li><strong>dns : DNS</strong> -- новая система непересекающихся множеств;</li>
            <li><strong>n : int --&nbsp;</strong>кол-во элементов в создаваемой СНМ;</li>
        </ul>

        <h4><strong>Объединение:</strong></h4>

        <p><strong>dns.unite(i1 : int, i2 : int),&nbsp;</strong>где:</p>

        <ul>
            <li><strong>dns : DNS</strong> -- система непересекающихся множеств;</li>
            <li><strong>i1 : int</strong> и <strong>i2 : int --&nbsp;</strong>номера объединяемых элементов;</li>
        </ul>

        <h4><strong>Получение корня:</strong></h4>

        <p><strong>dns.get_parent(i : int) : int</strong>, где:</p>

        <ul>
            <li><strong>dns : DNS</strong> -- система непересекающихся множеств;</li>
            <li><strong>i : int --&nbsp;</strong>номер элемента, корень которого надо получить;</li>
        </ul>

        <p>Фунция возвращает номер родителя. Соответственно&nbsp;<strong>проверка</strong>, находятся ли два элемента у одного корня (<strong>были</strong> ли <strong>объединены</strong>), осуществляется так:</p>

        <p><strong>dns.get_parent(i1) == dns.get_parent(i2)</strong>&nbsp;</p>

        <p>&nbsp;</p>

        <p><strong>Важно: если читающему это что-то скажет, то здесь использована оптимизация через логистику по размеру.</strong></p>

        <hr />
        <h2>mymath.py</h2>

        <p>Сий чудо-модуль реализует некоторые необычные функции, которые обозваны арифметикой чисто для того, чтобы никто не заглядывал в этот файл -- чтобы над их автором не ржали в голос.&nbsp;</p>

        <p><strong>dist(coords1 : Coords, coords2 : Coords)</strong> -- возвращает расстояние между точками <strong>coords2&nbsp;</strong>и<strong>&nbsp;</strong><strong>coords2</strong>.</p>

        <p><strong>rdf(f : file) </strong>-- считывает из файла&nbsp;<strong>f&nbsp;</strong>(открыть заранее) строку, стирает <strong>&quot;/n&quot;</strong> и возвращает результат.</p>

        <p><strong>equal(real1 : float, real2 : float) : bool</strong> -- возвращает <strong>True</strong>, если два вещественных числа <strong>real1</strong> и <strong>real2</strong>&nbsp;приблизительно равны (точность -- до <strong>10<sup>-6</sup></strong>), в противном случае -- <strong>False</strong>.</p>

        <p>&nbsp;</p>

        <p>класс <strong>Coords&nbsp;</strong>реализован во избежание лишнего использования кортежей. Поля:</p>

        <ul>
            <li><strong>x : int </strong>-- координата на оси <strong>х</strong>;</li>
            <li><strong>y : int </strong>-- координата на оси <strong>y</strong>;</li>
        </ul>

        <p>Геттеры и сеттеры -- стандартные, есть перегрузка конвертации в строку и оператора сравнения.</p>

        <p>Функция <strong>main()&nbsp;</strong>предназначена для быстрого написания геттеров и сеттеров. Принцип работы следующий:</p>

        <ol>
            <li>Запустить модуль;</li>
            <li>Ввести название выходного файла;</li>
            <li>Ввести название поля;</li>
            <li>Повторять третий шаг, пока не кончатся поля;</li>
            <li>Нажать <strong>ENTER</strong>;</li>
            <li>Открыть выходной файл;</li>
            <li>Скопировать готовые геттеры и сеттеры;</li>
            <li>Удалить выходной файл;\</li>
            <li>Использовать готовые геттеры и сеттеры по назначению;</li>
        </ol>

        <p>&nbsp;</p>

        <hr />
        <h2>OstTree.py</h2>

        <p>Сий чудо-модуль реализует очень <strong>авторскую версию</strong> алгоритма Краскала. Отличие от стандарта следущее: вместо сортировки перед началом работы происходит перемешивание массива. Это необходимо по той причине, что в данном проекте он применяется с целью генерации <strong>случайной</strong> карты; цимес в том, что карта должна иметь вид дерева (дабы повысить накал страстей в борьбе за транспортные и не только пути) и что пути могут быть случайной длины, значение которой находится в определённом диапазоне. Следовательно, нельзя всегда брать наименьшее значение (иначе пути всегда будут короткими) --&gt; надо брать случайные --&gt; поэтому используется перемешивание.</p>

        <p><strong>buildOstTree ( n : int, List : [ ( len : int, va : int, vb : int ) ] ) : [ [ (len : int, target : int) ] ] --&nbsp;</strong>возвращает построенное дерево (<strong>НЕ ЯВЛЯЮЩЕЕ ОСТОВНЫМ!!</strong>) в формате списка смежностей, где:</p>

        <p><strong>n : int </strong>-- кол-во вершин в генерируемом дереве;</p>

        <p><strong>List</strong> <strong>: [ ( len : int, va : int, vb : int ) ]&nbsp;</strong>-- список путей между вершинами, где каждый путь является кортежем из длины пути (целое число) и двух вершин (целые числа) -- это если кто не понял записи в начале;</p>

        <p>Возвращает список смежностей в виде двумерного массива, где массив под номером <strong>i</strong> символизирует <strong>i</strong>-ую вершину и содержит некоторое кол-во путей, где путь задаётся кортежем из длины пути (целое число)&nbsp;и вершины, куда он ведёт (целое число)&nbsp;-- это если кто не понял записи в начале.</p>

        <hr />
    </body>
</html>

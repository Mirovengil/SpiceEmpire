'''
Сий чудо-модуль реализует очень авторскую версию алгоритма Краскала.
Отличие от стандарта следущее: вместо сортировки перед началом работы
происходит перемешивание массива. Это необходимо по той причине, что в
данном проекте он применяется с целью генерации случайной карты; цимес
в том, что карта должна иметь вид дерева (дабы повысить накал страстей
в борьбе за транспортные и не только пути) и что пути могут быть
случайной длины, значение которой находится в определённом диапазоне.
Следовательно, нельзя всегда брать наименьшее значение (иначе пути
всегда будут короткими) --> надо брать случайные --> поэтому
используется перемешивание.
'''

from random import shuffle

import dns_realization


LEN = 0
VEA = 1
VEB = 2

def build_ost_tree(nummer, list_):
    '''
    buildOstTree(n:int, List:[(len:int, va:int, vb:int)]) :
    [[(len:int, target:int)]] -- возвращает построенное дерево
    (НЕ ЯВЛЯЮЩЕЕ ОСТОВНЫМ!!) в формате списка смежностей, где:

        nummer : int -- кол-во вершин в генерируемом дереве;
        
        list_ : [(len:int, va:int, vb:int)] -- список путей между
        вершинами, где каждый путь является кортежем из длины пути
        (целое число) и двух вершин (целые числа) -- это если
        кто не понял записи в начале;
    
    Возвращает список смежностей в виде двумерного массива, где массив
    под номером i символизирует i-ую вершину и содержит некоторое кол-во
    путей, где путь задаётся кортежем из длины пути (целое число) и
    вершины, куда он ведёт (целое число) -- это если кто не понял
    записи в начале.
    '''
    graph = []
    for i in range(nummer):
        graph.append([])
    dns = dns_realization.DNS(nummer)
    shuffle(list_)
    new_list = []
    for i in list_:
        if dns.get_parent(i[VEA]) != dns.get_parent(i[VEB]):
            new_list.append(i)
            dns.unite(i[VEA], i[VEB])
    for i in new_list:
        graph[i[VEA]].append((i[LEN], i[VEB]))
        graph[i[VEB]].append((i[LEN], i[VEA]))
    return graph
